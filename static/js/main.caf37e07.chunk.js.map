{"version":3,"sources":["../../node_modules/peerjs/dist sync","../../src/types.ts","reportWebVitals.ts","../../src/Logger.ts","../../src/PeerFactory.ts","../../src/Errors.ts","../../src/GenericGameAction.ts","../../src/GenericGameState.ts","../../src/NetworkStrategies/AbstractNetworkStrategy.ts","../../src/pause.ts","../../src/NetworkStrategies/StarHostStrategy.ts","../../src/NetworkStrategies/StarMemberStrategy.ts","../../src/DataStream.ts","../../src/StateManager.ts","../../src/NetworkStrategies/NoConcurrentStagingDecorator.ts","../../src/NetworkStrategies/AbstractNetworkStrategyDecorator.ts","../../src/Network.ts","../../src/useGameNetwork.tsx","../../src/withGenericGameReducer.ts","demo-gamenet/poker99/Poker99Action.ts","demo-gamenet/poker99/types.ts","../../src/useNetwork.ts","demo-gamenet/poker99/Poker99State.ts","demo-gamenet/poker99/constants.ts","demo-gamenet/poker99/Poker99Reducer.ts","demo-gamenet/poker99/utils.ts","demo-gamenet/withPoker99Network.tsx","demo-gamenet/Home.tsx","demo-gamenet/Room.tsx","demo-gamenet/poker99/aiAction.ts","demo-gamenet/Game.tsx","demo-gamenet/GameApp.tsx","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","PkgType","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","PeerFactory","constructor","options","this","peerHostConfig","process","host","port","Number","path","secure","config","JSON","peer","make","Promise","reject","AlreadyJoinedNetworkError","message","name","NotConnectedToPeerError","NoStagingStateError","NetworkBusyError","LoggerLevel","historyLevel","verbose","keep","_logs","pushLog","level","date","Date","getLogFunction","console","window","withColor","logFunction","css","prefix","withHistoryButWrongLineNumber","Proxy","apply","target","withAllFeatures","clear","printLogs","getLogs","log","logger","GameActionTypes","AbstractNetworkStrategy","network","peerFactory","isAdmin","leaving","stagingState","stagingChecksum","checksum","pause","a","setTimeout","StarHostStrategy","applyReducer","cs","broadcast","responses","errors","forceUpdate","promote","error","conn","data","handlePromote","dispatch","type","payload","dispatchMemberLeft","StarMemberStrategy","prevState","oldId","initAsStarHost","dispatchHostLeft","reconnectToHost","DataStream","connections","sentPromises","rest","getConn","pid","v4","pkgType","promises","Object","StateManager","initialState","onChange","historyMax","history","cloneDeep","state","length","NoConcurrentStagingDecorator","wrappedStrategy","handleDispatch","networkStrategy","handleCancel","setUpConnection","noConcurrentStaging","Network","stateReducer","initialStateOrManager","dataStream","getHistory","kick","stateManager","promise","networkName","initAsStarMember","oldPeer","connect","err","send","action","undefined","myId","pkg","newState","PlayerType","GenericGameState","minPlayer","maxPlayer","members","spectators","localPlayers","aiPlayers","nameDict","players","ready","started","compose","t","funcs","func","shuffle","i","j","Math","withMemberJoin","peerId","withRename","newName","withUpdateLocalAndAi","oldMasterPeerId","newMasterId","masterId","withRemovePlayer","withGameStart","who","withShuffleId","generalGameReducer","masterPeerId","withToggleReady","withAddAiPlayer","fakePeerId","nextState","withAddLocalPlayer","GameAppState","Poker99ActionType","Suit","useGameNetwork","useState","reducer","useMemo","useEffect","join","leave","connected","useNetwork","withGenericGameReducer","rename","READY","start","START","addLocal","addAi","setGameAppState","gameAppState","room","playerType","nameOrId","Poker99State","turn","direction","points","dead","drawDeck","trashDeck","playerDeck","winner","logs","cardAmount","1","2","3","4","5","6","7","8","9","10","11","12","13","withDrawCard","playerId","card","shift","push","withIncrementTurn","nextPlayerId","withBeforeNextTurn","current","cards","min","Infinity","index","forEach","k","suit","number","next","SPADE","minPossible","map","filter","Poker99Reducer","deck","getFullDeck","withInitGame","PLAY_CARD","cardStr","find","sign","amount","increase","withPlayCard","LOCAL_MOVE","END","Poker99Context","createContext","usePoker99","useContext","Home","substring","setName","setRoom","setError","value","disabled","onClick","catch","Room","handleStartClick","handleReadyClick","handleAddLocalClick","handleAddAiClick","displayPlayerType","NORMAL","LOCAL","AI","entries","key","placeholder","isNormalCard","includes","isSubtractable","isSkippingCard","Game","setTarget","increment","setIncrement","myPlayerId","myLocals","myAis","hideDeck","setHideDeck","renderedDeckId","setRenderedDeckId","prevTurn","useRef","handleError","n","normalCards","sort","b","card13","c","pmCards","aiAction","clearTimeout","d","clickCard","renderDeck","again","style","color","fontWeight","textDecorationLine","slice","reverse","s","GameApp","Component","WithGameNetwork","props","Provider","displayName","withPoker99Network","HOME","ROOM","GAME","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.caf37e07.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 140;","import { DataConnection } from 'peerjs'\r\n\r\nexport interface NetworkAction {\r\n  peerId?: string\r\n\r\n  [key: string]: unknown | undefined\r\n}\r\n\r\nexport interface NetworkState {\r\n  networkName?: string\r\n\r\n  [key: string]: unknown | undefined\r\n}\r\n\r\nexport interface PromiseHandler {\r\n  resolve: (data?: never) => void\r\n  reject: (error: string) => void\r\n}\r\n\r\nexport enum PkgType {\r\n  DISPATCH = 'DISPATCH',\r\n  ACK = 'ACK',\r\n  NACK = 'NACK',\r\n  PROMOTE = 'PROMOTE',\r\n  CANCEL = 'CANCEL',\r\n  SET_STATE = 'SET_STATE',\r\n  ASK_STATE = 'ASK_STATE',\r\n  KICK = 'KICK',\r\n}\r\n\r\nexport type Pkg<State extends NetworkState, Action extends NetworkAction> = (\r\n  { pkgType: PkgType.DISPATCH, data: Action }\r\n  | { pkgType: PkgType.ACK, data: string }\r\n  | { pkgType: PkgType.NACK, data: string }\r\n  | { pkgType: PkgType.CANCEL, data: string }\r\n  | { pkgType: PkgType.SET_STATE, data: NetworkState }\r\n  | { pkgType: PkgType.ASK_STATE }\r\n  | { pkgType: PkgType.KICK, data: string }\r\n  | { pkgType: PkgType }) & { pid?: string, data: never }\r\n\r\nexport type NetworkReducer<State extends NetworkState, Action extends NetworkAction> = (prevState: State, action: Action) => State\r\n\r\nexport interface SendResponse<T> {\r\n  conn: DataConnection\r\n  data?: T\r\n  error?: string\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","export enum LoggerLevel {\r\n  ALL,\r\n  TRACE,\r\n  LOG,\r\n  DEBUG,\r\n  INFO,\r\n  WARN,\r\n  ERROR,\r\n  OFF\r\n}\r\n\r\ninterface Log {\r\n  level: LoggerLevel\r\n  message: unknown[]\r\n  date: Date\r\n}\r\n\r\ntype LogFunction = (...message: unknown[]) => void\r\n\r\nclass Logger {\r\n  set historyLevel (value: LoggerLevel) {\r\n    this._historyLevel = value\r\n  }\r\n\r\n  set verboseLevel (value: LoggerLevel) {\r\n    this._verboseLevel = value\r\n  }\r\n\r\n  set keep (value: number) {\r\n    this._keep = value\r\n  }\r\n\r\n  private _historyLevel: LoggerLevel\r\n  private _verboseLevel: LoggerLevel\r\n  private _keep: number\r\n  private readonly _logs: Log[] = []\r\n\r\n  constructor (historyLevel: LoggerLevel, verbose: LoggerLevel, keep: number) {\r\n    this._historyLevel = historyLevel\r\n    this._verboseLevel = verbose\r\n    this._keep = keep\r\n  }\r\n\r\n  private readonly pushLog = (level: LoggerLevel, date: Date, ...message: unknown[]): void => {\r\n    if (this._logs.length >= this._keep) {\r\n      this._logs.shift()\r\n    }\r\n    this._logs.push({\r\n      level,\r\n      message,\r\n      date: new Date()\r\n    })\r\n  }\r\n\r\n  private readonly getLogFunction: (level: LoggerLevel) => LogFunction = level => {\r\n    if (level < this._verboseLevel) {\r\n      return () => {\r\n        //\r\n      }\r\n    }\r\n    switch (level) {\r\n      case LoggerLevel.INFO:\r\n        return console.info.bind(window.console)\r\n      case LoggerLevel.LOG:\r\n        return console.log.bind(window.console)\r\n      case LoggerLevel.DEBUG:\r\n        return console.log.bind(window.console)\r\n      case LoggerLevel.ERROR:\r\n        return console.error.bind(window.console)\r\n      case LoggerLevel.WARN:\r\n        return console.warn.bind(window.console)\r\n      case LoggerLevel.TRACE:\r\n        return console.trace.bind(window.console)\r\n      default:\r\n        return () => {\r\n          //\r\n        }\r\n    }\r\n  }\r\n\r\n  private readonly withColor: (level: LoggerLevel, date?: Date) => (logFunction: LogFunction) => LogFunction = (level, date) => logFunction => {\r\n    const css = {\r\n      [LoggerLevel.INFO]: 'color: DodgerBlue',\r\n      [LoggerLevel.LOG]: '',\r\n      [LoggerLevel.DEBUG]: 'color: Green',\r\n      [LoggerLevel.ERROR]: '',\r\n      [LoggerLevel.WARN]: '',\r\n      [LoggerLevel.TRACE]: 'color: Green',\r\n      [LoggerLevel.ALL]: '',\r\n      [LoggerLevel.OFF]: ''\r\n    }[level]\r\n    const prefix = date === undefined ? `%c[${LoggerLevel[level]}]` : `%c[${date.toISOString()} ${LoggerLevel[level]}]`\r\n    return Function.prototype.bind.call(logFunction, console, prefix, css) as LogFunction\r\n  }\r\n\r\n  private readonly withHistoryButWrongLineNumber: (level: LoggerLevel) => (logFunction: LogFunction) => LogFunction = level => logFunction => {\r\n    return new Proxy(logFunction, {\r\n      apply: (target: LogFunction, thisArg: unknown, argList: unknown[]) => {\r\n        const date = new Date()\r\n        this.pushLog(level, date, ...argList)\r\n        return target(...argList)\r\n      }\r\n    })\r\n  }\r\n\r\n  private readonly withAllFeatures: (level: LoggerLevel) => LogFunction = level => {\r\n    if (level >= this._historyLevel) {\r\n      return this.withHistoryButWrongLineNumber(level)(this.withColor(level)(this.getLogFunction(level)))\r\n    } else {\r\n      return this.withColor(level)(this.getLogFunction(level))\r\n    }\r\n  }\r\n\r\n  clear = (): void => {\r\n    this._logs.splice(0, this._logs.length)\r\n  }\r\n\r\n  public get info (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.INFO)\r\n  }\r\n\r\n  public get log (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.LOG)\r\n  }\r\n\r\n  public get debug (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.DEBUG)\r\n  }\r\n\r\n  public get error (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.ERROR)\r\n  }\r\n\r\n  public get warn (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.WARN)\r\n  }\r\n\r\n  public get trace (): LogFunction {\r\n    return this.withAllFeatures(LoggerLevel.TRACE)\r\n  }\r\n\r\n  printLogs = (): void => {\r\n    this._logs.forEach(({ level, message, date }) => {\r\n      this.withColor(level, date)(this.getLogFunction(level))(...message)\r\n    })\r\n  }\r\n\r\n  getLogs = (level = LoggerLevel.ALL): Log[] => {\r\n    return this._logs.filter((log) => log.level >= level)\r\n  }\r\n}\r\n\r\nexport const createLogger = (): Logger => {\r\n  switch (process.env.NODE_ENV) {\r\n    case 'development':\r\n      return new Logger(LoggerLevel.ALL, LoggerLevel.WARN, 100)\r\n    case 'production':\r\n      return new Logger(LoggerLevel.ALL, LoggerLevel.WARN, 100)\r\n    default:\r\n      return new Logger(LoggerLevel.OFF, LoggerLevel.OFF, 0)\r\n  }\r\n}\r\n\r\nexport const logger = createLogger()\r\n\r\nif (process.env.REACT_APP_SMNET_VERBOSE_ALL_NO_HISTORY !== undefined) {\r\n  logger.historyLevel = LoggerLevel.OFF\r\n  logger.verboseLevel = LoggerLevel.ALL\r\n}\r\n","import Peer from 'peerjs'\n\nexport class PeerFactory {\n  private readonly _options?: Peer.PeerJSOption\n  constructor (options?: Peer.PeerJSOption) {\n    if (options !== undefined) {\n      this._options = options\n    } else {\n      const peerHostConfig = process.env.REACT_APP_PEER_CONFIG\n      if (peerHostConfig === undefined && process.env.REACT_APP_PEER_HOST === undefined) {\n        this._options = undefined\n      } else {\n        this._options = {\n          host: process.env.REACT_APP_PEER_HOST ?? 'localhost',\n          port: Number.parseInt(process.env.REACT_APP_PEER_PORT ?? '9000', 10),\n          path: process.env.REACT_APP_PEER_PATH ?? '/peer',\n          secure: process.env.REACT_APP_PEER_SECURE === 'true',\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          config: peerHostConfig !== undefined ? JSON.parse(peerHostConfig) : undefined\n        }\n      }\n    }\n  }\n\n  make (id?: string): Peer {\n    return new Peer(id, this._options)\n  }\n\n  async makeAndOpen (id?: string): Promise<Peer> {\n    const peer = this.make(id)\n    return await new Promise((resolve, reject) => {\n      peer.on('open', () => {\n        resolve(peer)\n      })\n      peer.on('error', () => {\n        reject(peer)\n      })\n    })\n  }\n}\n","export class AlreadyJoinedNetworkError extends Error {\r\n  message = 'already joined network'\r\n  name = 'AlreadyJoinedNetworkError'\r\n}\r\n\r\nexport class PlayerNameAlreadyExistError extends Error {\r\n  message = 'player name already exist'\r\n  name = 'PlayerNameAlreadyExistError'\r\n}\r\n\r\nexport class NotConnectedToPeerError extends Error {\r\n  name = 'PlayerNameAlreadyExistError'\r\n\r\n  constructor (id: string) {\r\n    super()\r\n    this.message = `not connected to ${id}`\r\n  }\r\n}\r\n\r\nconst NO_STAGING_STATE = 'No Staging State'\r\nexport class NoStagingStateError extends Error {\r\n  message = NO_STAGING_STATE\r\n  name = 'NoStagingStateError'\r\n}\r\n\r\nexport class NetworkBusyError extends Error {\r\n  message = 'Network is busy, please retry later'\r\n  name = 'NetworkBusyError'\r\n}\r\n","import { NetworkAction } from 'smnet'\r\n\r\nexport type GenericGameAction = ({\r\n  type: GameActionTypes.RENAME\r\n  payload: string\r\n} | {\r\n  type: GameActionTypes.MEMBER_LEFT\r\n  payload: string\r\n} | {\r\n  type: GameActionTypes.HOST_LEFT\r\n  payload: string\r\n} | {\r\n  type: GameActionTypes.READY\r\n} | {\r\n  type: GameActionTypes.START\r\n} | {\r\n  type: GameActionTypes.MEMBER_JOIN\r\n} | {\r\n  type: GameActionTypes.ADD_AI\r\n  payload: string\r\n} | {\r\n  type: GameActionTypes.ADD_LOCAL\r\n  payload: string\r\n} | {\r\n  type: GameActionTypes.REMOVE_LOCAL_AI\r\n  payload: string\r\n}) & NetworkAction\r\n\r\nexport enum GameActionTypes {\r\n  MEMBER_JOIN = 'member-join',\r\n  MEMBER_LEFT = 'member-left',\r\n  HOST_LEFT = 'host-left',\r\n  RENAME = 'rename',\r\n  READY = 'ready',\r\n  START = 'start',\r\n  ADD_AI = 'add-ai',\r\n  ADD_LOCAL = 'add-local',\r\n  REMOVE_LOCAL_AI = 'remove-local-ai',\r\n}\r\n","import { NetworkState } from 'smnet'\r\n\r\nexport enum PlayerType {\r\n  NORMAL,\r\n  LOCAL,\r\n  AI\r\n}\r\n\r\nexport class GenericGameState implements NetworkState {\r\n  [key: string]: unknown | undefined\r\n\r\n  minPlayer = 1\r\n  maxPlayer = 4\r\n  networkName?: string\r\n  /**\r\n   * all connected members and their names\r\n   */\r\n  members: { [peerId: string]: string } = {}\r\n  /**\r\n   * peerId in this dict iff not playing\r\n   */\r\n  spectators: { [peerId: string]: true } = {}\r\n  /**\r\n   * local players, key: display name, value is the peerId that control this local player\r\n   */\r\n  localPlayers: { [name: string]: string } = {}\r\n  /**\r\n   * ai players, key: display name, value is the peerId that control this ai player\r\n   */\r\n  aiPlayers: { [name: string]: string } = {}\r\n  /**\r\n   * name to in game id map\r\n   */\r\n  nameDict: { [name: string]: number } = {}\r\n  /**\r\n   * in game id to name map\r\n   */\r\n  players: string[] = []\r\n  /**\r\n   * peerId in ready iff ready\r\n   */\r\n  ready: { [peerId: string]: true } = {}\r\n  started = false\r\n}\r\n","import { NetworkStrategy } from './NetworkStrategy'\r\nimport { Network } from '../Network'\r\nimport { NetworkAction, NetworkState } from '../types'\r\nimport Peer from 'peerjs'\r\nimport checksum from 'checksum'\r\nimport { NoStagingStateError } from '../Errors'\r\nimport { PeerFactory } from '../PeerFactory'\r\nimport { logger } from '../Logger'\r\n\r\n/**\r\n * AbstractNetworkStrategies is the base class of all other NetworkStrategies, it\r\n * hold the stagingState, which is an intermediate state computed when a point dispatch,\r\n *    but hasn't verified by other points,\r\n *    after getting verified we promote this stagingState to live state that is used by the application,\r\n *    NetworkStrategies can implement different logics to handle this\r\n * It always reject dispatch when there is statingState because even if we queue the dispatches in a buffer,\r\n *    the users may not be aware of what would be the new state before sending this request,\r\n *    the drawback is the user need to send their request manually later\r\n */\r\nexport abstract class AbstractNetworkStrategy<State extends NetworkState, Action extends NetworkAction> implements NetworkStrategy<State, Action> {\r\n  isAdmin = true\r\n  leaving = false\r\n  network: Network<State, Action>\r\n  stagingState?: State\r\n  protected peerFactory: PeerFactory\r\n\r\n  constructor (network: Network<State, Action>, peerFactory: PeerFactory) {\r\n    this.network = network\r\n    this.peerFactory = peerFactory\r\n  }\r\n\r\n  public abstract dispatch (action: Action): Promise<void>\r\n\r\n  public abstract handleDispatch (prevState: State, action: Action): Promise<State>\r\n\r\n  public async handlePromote (cs: string): Promise<void> {\r\n    if (this.stagingState !== undefined) {\r\n      const stagingChecksum = checksum(JSON.stringify(this.stagingState))\r\n      if (stagingChecksum === cs) {\r\n        this.network.setState(this.stagingState)\r\n        logger.info('promoted the stagingState', this.stagingState)\r\n        this.stagingState = undefined\r\n      } else {\r\n        logger.error(`Cannot promote, staging checksum is ${stagingChecksum} while requested to promote checksum of ${cs}`)\r\n        throw new Error('Cannot promote staging state with unmatched checksum')\r\n      }\r\n    } else {\r\n      logger.error('Cannot promote, there is no staging state')\r\n      throw new NoStagingStateError()\r\n    }\r\n    return await Promise.resolve()\r\n  }\r\n\r\n  public async handleCancel (cs: string): Promise<void> {\r\n    if (this.stagingState !== undefined) {\r\n      const stagingChecksum = checksum(JSON.stringify(this.stagingState))\r\n      if (stagingChecksum === cs) {\r\n        logger.info('canceled the stagingState', this.stagingState)\r\n        this.stagingState = undefined\r\n      } else {\r\n        logger.error(`Cannot cancel, staging checksum is ${stagingChecksum} while requested to cancel checksum of ${cs}`)\r\n        throw new Error('Cannot cancel staging state with unmatched checksum')\r\n      }\r\n    } else {\r\n      logger.error('Cannot cancel, there is no staging state')\r\n      throw new NoStagingStateError()\r\n    }\r\n    return await Promise.resolve()\r\n  }\r\n\r\n  public forceCancel (): void {\r\n    logger.info('force cancel the stagingState')\r\n    this.stagingState = undefined\r\n  }\r\n\r\n  public isBusy (): boolean {\r\n    return this.stagingState !== undefined\r\n  }\r\n\r\n  public abstract setUpConnection (conn: Peer.DataConnection): void\r\n}\r\n","export const pause = async (timeout: number): Promise<void> => await new Promise(resolve => {\r\n  setTimeout(() => {\r\n    resolve()\r\n  }, timeout)\r\n})\r\n","import { NetworkAction, NetworkState, PkgType } from '../types'\r\nimport Peer from 'peerjs'\r\nimport checksum from 'checksum'\r\nimport { AbstractNetworkStrategy } from './AbstractNetworkStrategy'\r\nimport { logger } from '../Logger'\r\nimport { pause } from '../pause'\r\n\r\n/**\r\n * Strategy of the center point of star network\r\n * star network host has the greatest power and force everyone to use his state\r\n */\r\nexport class StarHostStrategy<State extends NetworkState, Action extends NetworkAction> extends AbstractNetworkStrategy<State, Action> {\r\n  public async dispatch (action: Action): Promise<void> {\r\n    // run reducer locally, stage it and get checksum of new state\r\n    logger.debug('reduce locally', this.network.getState(), action)\r\n    this.stagingState = this.network.applyReducer(this.network.getState(), action)\r\n    const cs = checksum(JSON.stringify(this.stagingState))\r\n    logger.debug('stagingState', this.stagingState)\r\n\r\n    // tell other points to calculate\r\n    const responses = await this.network.broadcast(PkgType.DISPATCH, action)\r\n    logger.debug('obtained responses', responses)\r\n\r\n    // revert if anypoint threw any error\r\n    // force update if that point wont have same checksum\r\n    // promote if that point will have same checksum\r\n    const errors: Array<{ error: string, conn: Peer.DataConnection }> = []\r\n    const forceUpdate: Peer.DataConnection[] = []\r\n    const promote: Peer.DataConnection[] = []\r\n    responses.forEach(({ conn, data, error }) => {\r\n      if (error !== undefined) {\r\n        errors.push({ error, conn })\r\n      } else {\r\n        if (data !== cs) {\r\n          forceUpdate.push(conn)\r\n        } else {\r\n          promote.push(conn)\r\n        }\r\n      }\r\n    })\r\n    // logger.debug('different type of responses', { errors, forceUpdate, promote })\r\n    if (promote.length === responses.length) {\r\n      logger.debug('all can be promoted')\r\n    } else {\r\n      if (errors.length > 0) {\r\n        logger.error(`received ${errors.length} error from some peers`, errors)\r\n      }\r\n      if (forceUpdate.length > 0) {\r\n        logger.warn(`received ${forceUpdate.length} unmatched checksum from some peer, forceUpdating them`, forceUpdate)\r\n      }\r\n    }\r\n    if (errors.length > 0) {\r\n      await this.network.broadcast(PkgType.CANCEL, cs)\r\n      throw new Error(errors[0].error)\r\n    } else {\r\n      forceUpdate.map(async conn => {\r\n        await this.network.send(conn, PkgType.SET_STATE, this.stagingState)\r\n      })\r\n      promote.map(async conn => {\r\n        await this.network.send(conn, PkgType.PROMOTE, cs)\r\n      })\r\n    }\r\n\r\n    // promote owns' state after updating all others' state\r\n    await this.handlePromote(cs)\r\n  }\r\n\r\n  // other points' dispatch action will directly forward to host, and host broadcast the action\r\n  // if host cannot broadcast the action, it will feedback the source with error message\r\n  public async handleDispatch (prevState: State, action: Action): Promise<State> {\r\n    await this.dispatch(action)\r\n    return this.network.getState()\r\n  }\r\n\r\n  // no special handlers for star host\r\n  public setUpConnection (conn: Peer.DataConnection): void {\r\n    conn.on('close', () => {\r\n      this.dispatchMemberLeft(conn.peer).catch(logger.error)\r\n    })\r\n  }\r\n\r\n  private async dispatchMemberLeft (id: string): Promise<void> {\r\n    if (!this.leaving) {\r\n      try {\r\n        await this.network.dispatch({\r\n          type: 'member-left',\r\n          payload: id\r\n        } as unknown as Action)\r\n      } catch (e) {\r\n        await pause(1000)\r\n        await this.dispatchMemberLeft(id)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { NetworkAction, NetworkState, PkgType } from '../types'\r\nimport Peer from 'peerjs'\r\nimport { AbstractNetworkStrategy } from './AbstractNetworkStrategy'\r\nimport { pause } from '../pause'\r\nimport { logger } from '../Logger'\r\n\r\n/**\r\n * Strategy of the non-center point of star network\r\n * star network host has the greatest power and force everyone to use his state\r\n */\r\nexport class StarMemberStrategy<State extends NetworkState, Action extends NetworkAction> extends AbstractNetworkStrategy<State, Action> {\r\n  isAdmin = false\r\n\r\n  // just forward the dispatch to host\r\n  public async dispatch (action: Action): Promise<void> {\r\n    await this.network.broadcast(PkgType.DISPATCH, action)\r\n  }\r\n\r\n  // just do the reduce when receiving a dispatch\r\n  public async handleDispatch (prevState: State, action: Action): Promise<State> {\r\n    this.stagingState = this.network.applyReducer(prevState, action)\r\n    return await Promise.resolve(this.stagingState)\r\n  }\r\n\r\n  // when got disconnected from host, most probably due to host is down\r\n  // it will try to be the new host or reconnect to new host\r\n  public setUpConnection (conn: Peer.DataConnection): void {\r\n    conn.on('close', () => {\r\n      if (!this.leaving) {\r\n        this.recover().catch(logger.error)\r\n      }\r\n    })\r\n  }\r\n\r\n  private async recover (): Promise<void> {\r\n    const name = this.network.getNetworkName()\r\n    if (name !== undefined) {\r\n      try {\r\n        const oldId = this.network.myId\r\n        logger.debug('oldId', oldId)\r\n        await this.network.initAsStarHost(name, this.peerFactory)\r\n        logger.info('became the new host, changed peerId, notify others')\r\n        if (oldId !== undefined) {\r\n          await this.dispatchHostLeft(oldId)\r\n        }\r\n      } catch (e) {\r\n        await this.network.reconnectToHost(name)\r\n        // await this.network.connectToHost()\r\n      }\r\n    }\r\n  }\r\n\r\n  private async dispatchHostLeft (id: string): Promise<void> {\r\n    try {\r\n      await this.network.dispatch({\r\n        type: 'host-left',\r\n        payload: id\r\n      } as unknown as Action)\r\n    } catch (e) {\r\n      await pause(1000)\r\n      await this.dispatchHostLeft(id)\r\n    }\r\n  }\r\n}\r\n","import Peer, { DataConnection } from 'peerjs'\r\nimport { PkgType, PromiseHandler, SendResponse } from './types'\r\nimport { v4 } from 'uuid'\r\nimport { NotConnectedToPeerError } from './Errors'\r\n\r\nexport class DataStream {\r\n  private connections: { [id: string]: DataConnection } = {}\r\n  private sentPromises: { [id: string]: PromiseHandler } = {}\r\n\r\n  public reset (): void {\r\n    this.connections = {}\r\n  }\r\n\r\n  public registerConnection (conn: Peer.DataConnection): void {\r\n    this.connections[conn.peer] = conn\r\n  }\r\n\r\n  public unregisterConnection (conn: Peer.DataConnection): void {\r\n    const { [conn.peer]: a, ...rest } = this.connections\r\n    this.connections = rest\r\n  }\r\n\r\n  public getConnections (): { [id: string]: DataConnection } {\r\n    return this.connections\r\n  }\r\n\r\n  public async send<T, U = unknown> (id: string | DataConnection, pkgType: PkgType, data: T): Promise<SendResponse<U>> {\r\n    const conn = this.getConn(id)\r\n    return await new Promise((resolve, reject) => {\r\n      const pid = v4()\r\n      this.sentPromises[pid] = {\r\n        resolve: (data?: never) => resolve({ conn, data }),\r\n        reject: (error: string) => reject(new Error(error))\r\n      }\r\n      conn.send({ pkgType, data, pid })\r\n    })\r\n  }\r\n\r\n  public sendACK (connId: string | DataConnection, pid: string|undefined, data: unknown): void {\r\n    const conn = this.getConn(connId)\r\n    conn.send({ pkgType: PkgType.ACK, pid, data })\r\n  }\r\n\r\n  public sendNACK (connId: string | DataConnection, pid: string|undefined, data: unknown): void {\r\n    const conn = this.getConn(connId)\r\n    conn.send({ pkgType: PkgType.NACK, pid, data })\r\n  }\r\n\r\n  public async broadcast<T, U = unknown> (pkgType: PkgType, data: T): Promise<Array<SendResponse<U>>> {\r\n    const promises = Object.keys(this.connections).map(async id => await this.send<T, U>(id, pkgType, data))\r\n    return await Promise.all(promises)\r\n  }\r\n\r\n  public receiveACK (pid: string | undefined, response: never): void {\r\n    if (pid !== undefined && pid in this.sentPromises) {\r\n      const { resolve } = this.sentPromises[pid]\r\n      resolve(response)\r\n      this.removeSentPromise(pid)\r\n    }\r\n  }\r\n\r\n  public receiveNACK (pid: string | undefined, errorMessage: never): void {\r\n    if (pid !== undefined && pid in this.sentPromises) {\r\n      const { reject } = this.sentPromises[pid]\r\n      reject(errorMessage)\r\n      this.removeSentPromise(pid)\r\n    }\r\n  }\r\n\r\n  private removeSentPromise (pid: string): void {\r\n    const { [pid]: p, ...rest } = this.sentPromises\r\n    this.sentPromises = rest\r\n  }\r\n\r\n  private getConn (id: string | DataConnection): DataConnection {\r\n    if (typeof id === 'string') {\r\n      const conn = this.connections[id]\r\n      if (conn !== undefined) {\r\n        return conn\r\n      }\r\n      throw new NotConnectedToPeerError(id)\r\n    } else {\r\n      return id\r\n    }\r\n  }\r\n}\r\n","import { NetworkState } from './types'\r\nimport cloneDeep from 'clone-deep'\r\n\r\ntype Setter<State extends NetworkState> = (state: State) => void\r\n\r\ntype Resetter = () => void\r\n\r\n/**\r\n * Make State changes policy extensible\r\n * Only have get, set and reset\r\n */\r\nexport class StateManager<State extends NetworkState> {\r\n  private readonly _set: Setter<State>\r\n  private readonly _reset: Resetter\r\n  private readonly initialState!: State\r\n  private state!: State\r\n  private readonly history: State[] = []\r\n  private readonly historyMax: number\r\n\r\n  constructor (initialState: State, onChange?: Setter<State>, historyMax = 0) {\r\n    this.historyMax = historyMax\r\n    this.initialState = cloneDeep(initialState)\r\n    this._reset = () => this.set(cloneDeep(this.initialState))\r\n    this.state = initialState\r\n\r\n    this._set = onChange ?? ((state: State) => {\r\n      this.state = state\r\n    })\r\n  }\r\n\r\n  public get (): State {\r\n    return this.state\r\n  }\r\n\r\n  public set (state: State): void {\r\n    this.state = state\r\n    if (this.historyMax > 0) {\r\n      if (this.history.length >= this.historyMax) {\r\n        this.history.shift()\r\n      }\r\n      this.history.push(cloneDeep(state))\r\n    }\r\n    this._set({ ...state })\r\n  }\r\n\r\n  public reset (): void {\r\n    this._reset()\r\n  }\r\n\r\n  public getHistory (): State[] {\r\n    return this.history\r\n  }\r\n\r\n  static make<State extends NetworkState> (initialState: State, onChange?: Setter<State>, historyMax?: number): StateManager<State> {\r\n    return new StateManager<State>(initialState, onChange, historyMax)\r\n  }\r\n}\r\n","import { AbstractNetworkStrategyDecorator } from './AbstractNetworkStrategyDecorator'\r\nimport { NetworkAction, NetworkState } from '../types'\r\nimport { NetworkBusyError } from '../Errors'\r\nimport { NetworkStrategy } from './NetworkStrategy'\r\nimport { logger } from '../Logger'\r\n\r\nexport class NoConcurrentStagingDecorator<State extends NetworkState, Action extends NetworkAction> extends AbstractNetworkStrategyDecorator<State, Action> {\r\n  public async dispatch (action: Action): Promise<void> {\r\n    if (this.stagingState !== undefined) {\r\n      logger.error('cannot dispatch when there is staging state', this.stagingState)\r\n      throw new NetworkBusyError()\r\n    }\r\n    // next action\r\n    return await this.wrappedStrategy.dispatch(action)\r\n  }\r\n\r\n  public async handleDispatch (prevState: State, action: Action): Promise<State> {\r\n    if (this.stagingState !== undefined) {\r\n      logger.error('cannot handle dispatch request when there is staging state', this.stagingState)\r\n      throw new NetworkBusyError()\r\n    }\r\n    // next action\r\n    return await this.wrappedStrategy.handleDispatch(prevState, action)\r\n  }\r\n}\r\n\r\nexport const noConcurrentStaging = <State extends NetworkState, Action extends NetworkAction> (networkStrategy: NetworkStrategy<State, Action>): NetworkStrategy<State, Action> => {\r\n  return new NoConcurrentStagingDecorator(networkStrategy)\r\n}\r\n","import { NetworkStrategy } from './NetworkStrategy'\r\nimport { NetworkAction, NetworkState } from '../types'\r\nimport { Network } from '../Network'\r\nimport { DataConnection } from 'peerjs'\r\n\r\nexport abstract class AbstractNetworkStrategyDecorator<State extends NetworkState, Action extends NetworkAction> implements NetworkStrategy<State, Action> {\r\n  protected wrappedStrategy: NetworkStrategy<State, Action>\r\n\r\n  get stagingState (): State | undefined {\r\n    return this.wrappedStrategy.stagingState\r\n  }\r\n\r\n  set stagingState (value: State | undefined) {\r\n    this.wrappedStrategy.stagingState = value\r\n  }\r\n\r\n  get network (): Network<State, Action> {\r\n    return this.wrappedStrategy.network\r\n  }\r\n\r\n  get leaving (): boolean {\r\n    return this.wrappedStrategy.leaving\r\n  }\r\n\r\n  set leaving (flag: boolean) {\r\n    this.wrappedStrategy.leaving = flag\r\n  }\r\n\r\n  get isAdmin (): boolean {\r\n    return this.wrappedStrategy.isAdmin\r\n  }\r\n\r\n  set isAdmin (flag: boolean) {\r\n    this.wrappedStrategy.isAdmin = flag\r\n  }\r\n\r\n  constructor (networkStrategy: NetworkStrategy<State, Action>) {\r\n    this.wrappedStrategy = networkStrategy\r\n  }\r\n\r\n  public async dispatch (action: Action): Promise<void> {\r\n    return await this.wrappedStrategy.dispatch(action)\r\n  }\r\n\r\n  public forceCancel (): void {\r\n    return this.wrappedStrategy.forceCancel()\r\n  }\r\n\r\n  public async handleCancel (cs: string): Promise<void> {\r\n    return await this.wrappedStrategy.handleCancel(cs)\r\n  }\r\n\r\n  public async handleDispatch (prevState: State, action: Action): Promise<State> {\r\n    return await this.wrappedStrategy.handleDispatch(prevState, action)\r\n  }\r\n\r\n  public async handlePromote (cs: string): Promise<void> {\r\n    return await this.wrappedStrategy.handlePromote(cs)\r\n  }\r\n\r\n  public isBusy (): boolean {\r\n    return this.wrappedStrategy.isBusy()\r\n  }\r\n\r\n  public setUpConnection (conn: DataConnection): void {\r\n    return this.wrappedStrategy.setUpConnection(conn)\r\n  }\r\n}\r\n","import { NetworkAction, NetworkReducer, NetworkState, Pkg, PkgType, SendResponse } from './types'\r\nimport { PeerFactory } from './PeerFactory'\r\nimport Peer, { DataConnection } from 'peerjs'\r\nimport { NetworkStrategy } from './NetworkStrategies/NetworkStrategy'\r\nimport { StarHostStrategy } from './NetworkStrategies/StarHostStrategy'\r\nimport checksum from 'checksum'\r\nimport { AlreadyJoinedNetworkError } from './Errors'\r\nimport { StarMemberStrategy } from './NetworkStrategies/StarMemberStrategy'\r\nimport { DataStream } from './DataStream'\r\nimport { StateManager } from './StateManager'\r\nimport { noConcurrentStaging } from './NetworkStrategies/NoConcurrentStagingDecorator'\r\nimport { logger } from './Logger'\r\n\r\n/**\r\n * The main Network class, which holds\r\n * - a networkStrategy that handles behavior when in different kinds of network and position, e.g. the center point in StarNetwork vs other points in that\r\n * - a stateManager, which holds the data state of this network, you may supply you own version of stateManager such as observableStateManager\r\n * - a dataStream, which handle the data exchange between different points in the network\r\n * and it can\r\n * - join a network\r\n * - leave the joined network\r\n * - dispatch changes on the data state\r\n * - get the newest data state\r\n */\r\nexport class Network<State extends NetworkState, Action extends NetworkAction> {\r\n  private peer?: Peer\r\n  private readonly stateManager: StateManager<State>\r\n  private readonly stateReducer: NetworkReducer<State, Action>\r\n  private networkStrategy?: NetworkStrategy<State, Action>\r\n  private networkName?: string\r\n  private readonly dataStream = new DataStream()\r\n\r\n  constructor (stateReducer: NetworkReducer<State, Action>, initialStateOrManager: State | StateManager<State>) {\r\n    if (initialStateOrManager instanceof StateManager) {\r\n      this.stateManager = initialStateOrManager\r\n    } else {\r\n      this.stateManager = StateManager.make(initialStateOrManager)\r\n    }\r\n    this.stateReducer = stateReducer\r\n  }\r\n\r\n  public get myId (): string | undefined {\r\n    return this.peer?.id\r\n  }\r\n\r\n  public get connected (): boolean {\r\n    return this.networkName !== undefined\r\n  }\r\n\r\n  public getNetworkName (): string | undefined {\r\n    return this.networkName\r\n  }\r\n\r\n  public setState (state: State): void {\r\n    this.stateManager.set(state)\r\n  }\r\n\r\n  public getState (): State {\r\n    return this.stateManager.get()\r\n  }\r\n\r\n  public get state (): State {\r\n    return this.getState()\r\n  }\r\n\r\n  public getHistory = (): State[] => {\r\n    return this.stateManager.getHistory()\r\n  }\r\n\r\n  public get isAdmin (): boolean {\r\n    return this.networkStrategy?.isAdmin ?? false\r\n  }\r\n\r\n  /**\r\n   * reduce a given state which changing owns' state\r\n   * @param prevState\r\n   * @param action\r\n   */\r\n  public applyReducer (prevState: State, action: Action): State {\r\n    return this.stateReducer(prevState, action)\r\n  }\r\n\r\n  /**\r\n   * reduce owns' state\r\n   * @param action\r\n   */\r\n  public reduce (action: Action): void {\r\n    this.stateManager.set(this.stateReducer(this.stateManager.get(), action))\r\n  }\r\n\r\n  public kick = async (id: string): Promise<void> => {\r\n    if (this.getNeighbor()?.includes(id) ?? false) {\r\n      await this.send(id, PkgType.KICK, id)\r\n    } else {\r\n      await this.broadcast(PkgType.KICK, id)\r\n    }\r\n  }\r\n\r\n  public async leave (): Promise<void> {\r\n    if (this.peer !== undefined) {\r\n      if (this.networkStrategy !== undefined) {\r\n        this.networkStrategy.leaving = true\r\n      }\r\n      const promise = new Promise(resolve => this.peer?.on('close', resolve))\r\n      this.peer.destroy()\r\n      await promise\r\n      this.peer = undefined\r\n      this.networkName = undefined\r\n      this.dataStream.reset()\r\n      this.stateManager.reset()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Join a network, give a peerFactory if you have different PeerJS configuration\r\n   * @param networkName\r\n   * @param peerFactory\r\n   */\r\n  public async join (networkName: string, peerFactory?: PeerFactory): Promise<void> {\r\n    if (this.peer !== undefined) {\r\n      throw new AlreadyJoinedNetworkError()\r\n    }\r\n    peerFactory = peerFactory ?? new PeerFactory()\r\n    try {\r\n      await this.initAsStarHost(networkName, peerFactory)\r\n      this.stateManager.reset()\r\n      this.setState({ ...this.getState(), networkName })\r\n    } catch (e) {\r\n      logger.info('cannot init as host, try to init as member')\r\n      await this.initAsStarMember(networkName, peerFactory)\r\n    }\r\n    await this.dispatch({\r\n      type: 'member-join'\r\n    } as unknown as Action)\r\n  }\r\n\r\n  /**\r\n   * set up StarHostStrategy\r\n   * @param name\r\n   * @param peerFactory\r\n   */\r\n  public async initAsStarHost (name: string, peerFactory: PeerFactory): Promise<void> {\r\n    logger.info('initing as host')\r\n    const oldPeer = this.peer\r\n    this.peer = await peerFactory.makeAndOpen(name)\r\n    this.peer.on('connection', conn => {\r\n      logger.info('received connection with', conn.peer)\r\n      this.setUpConnection(conn)\r\n    })\r\n    this.networkName = name\r\n    this.networkStrategy = noConcurrentStaging(new StarHostStrategy(this, peerFactory))\r\n    oldPeer?.destroy()\r\n    logger.info('inited as host')\r\n  }\r\n\r\n  /**\r\n   * set up StarMemberStrategy\r\n   * @param name\r\n   * @param peerFactory\r\n   */\r\n  public async initAsStarMember (name: string, peerFactory: PeerFactory): Promise<void> {\r\n    logger.info('initing as member')\r\n    this.networkStrategy = noConcurrentStaging(new StarMemberStrategy(this, peerFactory))\r\n    this.peer = await peerFactory.makeAndOpen()\r\n    logger.info('opened peer')\r\n    await this.reconnectToHost(name)\r\n  }\r\n\r\n  public async reconnectToHost (name: string): Promise<void> {\r\n    if (this.peer === undefined) return\r\n    const conn = this.peer.connect(name)\r\n    this.setUpConnection(conn)\r\n    await new Promise((resolve, reject) => {\r\n      conn.on('open', () => {\r\n        resolve()\r\n      })\r\n      conn.on('error', err => {\r\n        reject(err)\r\n      })\r\n    })\r\n    logger.info('opened connection with host')\r\n    this.dataStream.registerConnection(conn)\r\n    this.networkName = name\r\n    logger.info('requesting state from host')\r\n    const { data } = await this.dataStream.send<undefined, State>(name, PkgType.ASK_STATE, undefined)\r\n    if (data !== undefined) {\r\n      logger.info('updating the state got from host', data)\r\n      this.setState(data)\r\n    }\r\n    logger.info('inited as member')\r\n  }\r\n\r\n  /**\r\n   * Get the neighboring connections of this point\r\n   */\r\n  public getNeighbor (): string[] | undefined {\r\n    if (this.peer === undefined) {\r\n      return undefined\r\n    }\r\n    return Object.keys(this.dataStream.getConnections())\r\n  }\r\n\r\n  public async send<T, U = unknown> (id: string | DataConnection, pkgType: PkgType, data: T): Promise<SendResponse<U>> {\r\n    return await this.dataStream.send(id, pkgType, data)\r\n  }\r\n\r\n  public async broadcast<T, U = unknown> (pkgType: PkgType, data: T): Promise<Array<SendResponse<U>>> {\r\n    return await this.dataStream.broadcast(pkgType, data)\r\n  }\r\n\r\n  public async dispatch (action: Action): Promise<void> {\r\n    action.peerId = this.myId\r\n    if (this.myId !== undefined && this.myId !== null) {\r\n      logger.info('dispatching action', action)\r\n      await this.networkStrategy?.dispatch(action)\r\n      logger.info('dispatched action', action)\r\n    } else {\r\n      logger.error('not connected')\r\n    }\r\n  }\r\n\r\n  private setUpConnection (conn: DataConnection): void {\r\n    conn.on('open', () => {\r\n      logger.info('opened connection with', conn.peer)\r\n      this.dataStream.registerConnection(conn)\r\n    })\r\n    conn.on('close', () => {\r\n      logger.info('closed connection with', conn.peer)\r\n      this.dataStream.unregisterConnection(conn)\r\n    })\r\n    conn.on('data', (pkg: Pkg<State, Action>) => this.dataHandler(pkg, conn))\r\n    this.networkStrategy?.setUpConnection(conn)\r\n  }\r\n\r\n  /**\r\n   * handling different kinds of package\r\n   *\r\n   * @param pkg\r\n   * @param conn\r\n   * @private\r\n   */\r\n  private dataHandler (pkg: Pkg<State, Action>, conn: Peer.DataConnection): void {\r\n    const { pid, pkgType, data } = pkg\r\n    logger.debug('received pkg from', conn.peer, pkg)\r\n    switch (pkgType) {\r\n      case PkgType.DISPATCH:\r\n        // ack with new state's checksum\r\n        // nack with error message\r\n        this.networkStrategy?.handleDispatch(this.getState(), data)\r\n          .then(newState => {\r\n            const cs: string = checksum(JSON.stringify(newState))\r\n            this.dataStream.sendACK(conn, pid, cs)\r\n          })\r\n          .catch((error: Error) => {\r\n            this.dataStream.sendNACK(conn, pid, error.message)\r\n          })\r\n        break\r\n      case PkgType.ACK:\r\n        this.dataStream.receiveACK(pid, data)\r\n        break\r\n      case PkgType.NACK:\r\n        this.dataStream.receiveNACK(pid, data)\r\n        break\r\n      case PkgType.PROMOTE:\r\n        // promote need to provide checksum, only promote when checksum same as that of staging state\r\n        this.networkStrategy?.handlePromote(data)\r\n          .then(() => this.dataStream.sendACK(conn, pid, data))\r\n          .catch((error: Error) => this.dataStream.sendNACK(conn, pid, error.message))\r\n        break\r\n      case PkgType.CANCEL:\r\n        // cancel need to provide checksum, only cancel when checksum same as that of staging state\r\n        this.networkStrategy?.handleCancel(data)\r\n          .then(() => this.dataStream.sendACK(conn, pid, data))\r\n          .catch((error: Error) => this.dataStream.sendNACK(conn, pid, error.message))\r\n        break\r\n      case PkgType.SET_STATE:\r\n        // ignore whatever staging state, just set state and cancel the staging state\r\n        this.setState(data)\r\n        this.networkStrategy?.forceCancel()\r\n        break\r\n      case PkgType.ASK_STATE:\r\n        this.dataStream.sendACK(conn, pid, this.state)\r\n        break\r\n      case PkgType.KICK:\r\n        if (data === this.myId) {\r\n          logger.info('you got kicked out of network')\r\n          this.leave().catch(logger.error)\r\n        } else {\r\n          this.send(data, pkgType, data).catch(logger.error)\r\n        }\r\n    }\r\n  }\r\n}\r\n","import { logger, NetworkReducer, useNetwork } from 'smnet'\r\nimport { withGenericGameReducer } from './withGenericGameReducer'\r\nimport { GenericGameState, PlayerType } from './GenericGameState'\r\nimport { GameActionTypes, GenericGameAction } from './GenericGameAction'\r\nimport { ReactNode, useEffect, useState } from 'react'\r\n\r\nexport interface GameContextInterface<State, Action> {\r\n  connect: (name: string, room: string) => Promise<void>\r\n  leave: () => Promise<void>\r\n  gameAppState: GameAppState\r\n  state: State\r\n  room?: string\r\n  isAdmin: boolean\r\n  myId?: string\r\n  kick: (id: string) => Promise<void>\r\n  ready: () => Promise<void>\r\n  start: () => Promise<void>\r\n  addLocal: (name: string) => Promise<void>\r\n  addAi: (name: string) => Promise<void>\r\n  dispatch: (action: Action) => Promise<void>\r\n  playerType: (nameOrId: string | number) => PlayerType\r\n}\r\n\r\nexport enum GameAppState {\r\n  HOME,\r\n  ROOM,\r\n  GAME\r\n}\r\n\r\nexport interface GameNetworkProps<State extends GenericGameState, Action extends GenericGameAction> {\r\n  children: ReactNode\r\n  reducer: NetworkReducer<State, Action>\r\n  initialState: State\r\n}\r\n\r\nexport const useGameNetwork = <State extends GenericGameState, Action extends GenericGameAction>(reducer: NetworkReducer<State, Action>, initialState: State): GameContextInterface<State, Action> => {\r\n  const [gameAppState, setGameAppState] = useState(GameAppState.HOME)\r\n  const network = useNetwork(withGenericGameReducer(reducer), initialState)\r\n\r\n  const playerType = (nameOrId: string | number): PlayerType => {\r\n    const name: string = typeof nameOrId === 'string' ? nameOrId : network.state.players[nameOrId]\r\n    const peerId: string | undefined = Object.entries(network.state.members).find(([_peerId, n]) => name === n)?.[0]\r\n    if (peerId === undefined) {\r\n      return PlayerType.NORMAL\r\n    }\r\n    if (peerId in network.state.aiPlayers) {\r\n      return PlayerType.AI\r\n    } else if (peerId in network.state.localPlayers) {\r\n      return PlayerType.LOCAL\r\n    } else {\r\n      return PlayerType.NORMAL\r\n    }\r\n  }\r\n  const rename = async (name: string): Promise<void> => {\r\n    await network.dispatch({\r\n      type: GameActionTypes.RENAME,\r\n      payload: name\r\n    })\r\n  }\r\n  const ready = async (): Promise<void> => {\r\n    await network.dispatch({\r\n      type: GameActionTypes.READY\r\n    })\r\n  }\r\n  const start = async (): Promise<void> => {\r\n    await network.dispatch({\r\n      type: GameActionTypes.START\r\n    })\r\n  }\r\n  const addLocal = async (name: string): Promise<void> => {\r\n    await network.dispatch({\r\n      type: GameActionTypes.ADD_LOCAL,\r\n      payload: name\r\n    })\r\n  }\r\n  const addAi = async (name: string): Promise<void> => {\r\n    await network.dispatch({\r\n      type: GameActionTypes.ADD_AI,\r\n      payload: name\r\n    })\r\n  }\r\n  const connect = async (name: string, room: string): Promise<void> => {\r\n    try {\r\n      logger.info('connecting', room)\r\n      await network.join(room)\r\n      logger.info('entering with name', name)\r\n      await rename(name)\r\n      logger.info('connected', room)\r\n    } catch (e) {\r\n      logger.error(e)\r\n      await leave()\r\n      throw e\r\n    }\r\n  }\r\n  const leave = async (): Promise<void> => {\r\n    logger.info('leaving')\r\n    await network.leave()\r\n  }\r\n  const kick = async (peerId: string): Promise<void> => {\r\n    logger.info('leaving')\r\n    if (peerId in network.state.aiPlayers || peerId in network.state.localPlayers) {\r\n      await network.dispatch({\r\n        type: GameActionTypes.REMOVE_LOCAL_AI,\r\n        payload: peerId\r\n      })\r\n    } else {\r\n      await network.kick(peerId)\r\n    }\r\n  }\r\n  useEffect(() => {\r\n    if (network.state.started && network.networkName !== undefined) {\r\n      setGameAppState(GameAppState.GAME)\r\n    } else if (network.networkName !== undefined) {\r\n      setGameAppState(GameAppState.ROOM)\r\n    } else {\r\n      setGameAppState(GameAppState.HOME)\r\n    }\r\n  }, [network.state, network.networkName])\r\n  return {\r\n    connect,\r\n    gameAppState,\r\n    state: network.state as State,\r\n    room: network.networkName,\r\n    leave,\r\n    isAdmin: network.isAdmin,\r\n    myId: network.myId,\r\n    kick,\r\n    ready,\r\n    start,\r\n    dispatch: network.dispatch,\r\n    addLocal,\r\n    addAi,\r\n    playerType\r\n  }\r\n}\r\n","import { NetworkReducer } from 'smnet'\r\nimport { GenericGameState } from './GenericGameState'\r\nimport { GameActionTypes, GenericGameAction } from './GenericGameAction'\r\nimport { v4 } from 'uuid'\r\n\r\ntype StateMapper = (prevState: GenericGameState) => GenericGameState\r\n\r\nexport const compose: <T>(...func: Array<(t: T) => T>) => ((t: T) => T) = (...funcs) => t => {\r\n  return funcs.reverse().reduce((p, func) => func(p), t)\r\n}\r\n\r\nexport const shuffle = <T> (a: T[]): T[] => {\r\n  for (let i = a.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [a[i], a[j]] = [a[j], a[i]]\r\n  }\r\n  return a\r\n}\r\n\r\nconst withMemberJoin: (peerId: string) => StateMapper = peerId => (prevState) => {\r\n  if (peerId in prevState.members) {\r\n    throw new Error(`peerId ${peerId} already joined this room`)\r\n  }\r\n  if ((prevState.maxPlayer > 0 && Object.values(prevState.members).length >= prevState.maxPlayer) || prevState.started) {\r\n    prevState.spectators[peerId] = true\r\n  }\r\n  return { ...prevState, members: { ...prevState.members, [peerId]: '' } }\r\n}\r\n\r\nconst withRename: (peerId: string, newName: string) => StateMapper = (peerId, newName) => (prevState) => {\r\n  if (Object.values(prevState.members).includes(newName)) {\r\n    throw new Error(`there is already someone named ${newName}`)\r\n  }\r\n  if (prevState.started && Object.keys(prevState.nameDict).includes(newName)) {\r\n    const { [peerId]: _, ...spectators } = prevState.spectators\r\n    prevState.spectators = spectators\r\n  }\r\n  return { ...prevState, members: { ...prevState.members, [peerId]: newName } }\r\n}\r\n\r\nconst withUpdateLocalAndAi: (oldMasterId: string, newMasterId: string | undefined) => StateMapper = (oldMasterPeerId, newMasterId) => prevState => {\r\n  const localPlayers: Record<string, string> = {}\r\n  const aiPlayers: Record<string, string> = {}\r\n  Object.entries(prevState.localPlayers).forEach(([fakePeerId, masterId]) => {\r\n    if (masterId !== oldMasterPeerId) {\r\n      localPlayers[fakePeerId] = masterId\r\n    } else if (newMasterId !== undefined) {\r\n      localPlayers[fakePeerId] = newMasterId\r\n    }\r\n  })\r\n  Object.entries(prevState.aiPlayers).forEach(([fakePeerId, masterId]) => {\r\n    if (masterId !== oldMasterPeerId) {\r\n      aiPlayers[fakePeerId] = masterId\r\n    } else if (newMasterId !== undefined) {\r\n      aiPlayers[fakePeerId] = newMasterId\r\n    }\r\n  })\r\n  return { ...prevState, localPlayers, aiPlayers }\r\n}\r\n\r\nconst withRemovePlayer: (peerId: string) => StateMapper = (peerId) => prevState => {\r\n  const { [peerId]: _1, ...members } = prevState.members\r\n  const { [peerId]: _2, ...localPlayers } = prevState.localPlayers\r\n  const { [peerId]: _3, ...aiPlayers } = prevState.aiPlayers\r\n  return { ...prevState, members, localPlayers, aiPlayers }\r\n}\r\n\r\nconst withToggleReady: (peerId: string) => StateMapper = (peerId) => prevState => {\r\n  if (prevState.ready[peerId]) {\r\n    const { [peerId]: _, ...ready } = prevState.ready\r\n    return { ...prevState, ready }\r\n  } else {\r\n    return { ...prevState, ready: { ...prevState.ready, [peerId]: true } }\r\n  }\r\n}\r\n\r\nconst withShuffleId: StateMapper = (prevState) => {\r\n  const players = shuffle(Object.entries(prevState.members).filter(([peerId]) => !prevState.spectators[peerId]).map(a => a[1]))\r\n  if (players.length > prevState.maxPlayer) {\r\n    throw new Error(`Too much players, max: ${prevState.maxPlayer}, got: ${players.length}`)\r\n  }\r\n  if (players.length < prevState.minPlayer) {\r\n    throw new Error(`Not enough players, min: ${prevState.minPlayer}, got: ${players.length}`)\r\n  }\r\n  const nameDict: Record<string, number> = {}\r\n  players.forEach((name, id) => {\r\n    nameDict[name] = id\r\n  })\r\n  return { ...prevState, nameDict, players }\r\n}\r\n\r\nconst withGameStart: (networkName: string) => StateMapper = (networkName) => prevState => {\r\n  if (prevState.started) {\r\n    throw new Error('Started already')\r\n  }\r\n  const who = Object.keys(prevState.members)\r\n    .filter(id => id !== networkName)\r\n    .filter(id => !prevState.spectators[id])\r\n    .filter(id => prevState.localPlayers[id] === undefined)\r\n    .filter(id => prevState.aiPlayers[id] === undefined)\r\n    .filter((id) => id !== undefined && !(prevState.ready[id] ?? false))\r\n  if (who.length === 0) {\r\n    return withShuffleId({ ...prevState, started: true })\r\n  } else {\r\n    throw new Error(`${who.map(id => prevState.members[id]).join(',')} not ready yet`)\r\n  }\r\n}\r\n\r\nconst withAddAiPlayer: (name: string, masterPeerId: string) => StateMapper = (name, masterPeerId) => prevState => {\r\n  const fakePeerId = `ai-${name}-${v4()}`\r\n  const nextState = compose(\r\n    withRename(fakePeerId, name),\r\n    withMemberJoin(fakePeerId)\r\n  )(prevState)\r\n  return { ...nextState, aiPlayers: { ...nextState.aiPlayers, [fakePeerId]: masterPeerId } }\r\n}\r\n\r\nconst withAddLocalPlayer: (name: string, masterPeerId: string) => StateMapper = (name, masterPeerId) => prevState => {\r\n  const fakePeerId = `local-${name}-${v4()}`\r\n  const nextState = compose(\r\n    withRename(fakePeerId, name),\r\n    withMemberJoin(fakePeerId)\r\n  )(prevState)\r\n  return { ...nextState, localPlayers: { ...nextState.localPlayers, [fakePeerId]: masterPeerId } }\r\n}\r\n\r\nexport const generalGameReducer: NetworkReducer<GenericGameState, GenericGameAction> = (prevState, action) => {\r\n  const peerId = action.peerId\r\n  if (peerId === undefined) {\r\n    throw new Error('expect peerId in action')\r\n  }\r\n  const networkName = prevState.networkName\r\n  if (networkName === undefined) {\r\n    throw new Error('expect networkName in prevState')\r\n  }\r\n  switch (action.type) {\r\n    case GameActionTypes.MEMBER_JOIN:\r\n      return withMemberJoin(peerId)(prevState)\r\n    case GameActionTypes.RENAME:\r\n      return withRename(peerId, action.payload)(prevState)\r\n    case GameActionTypes.MEMBER_LEFT:\r\n      return compose(\r\n        withUpdateLocalAndAi(action.payload, networkName),\r\n        withRemovePlayer(action.payload)\r\n      )(prevState)\r\n    case GameActionTypes.HOST_LEFT:\r\n      return compose(\r\n        withUpdateLocalAndAi(action.payload, networkName),\r\n        withRename(networkName, prevState.members[action.payload]),\r\n        withRemovePlayer(action.payload)\r\n      )(prevState)\r\n    case GameActionTypes.READY:\r\n      return withToggleReady(peerId)(prevState)\r\n    case GameActionTypes.START:\r\n      return withGameStart(networkName)(prevState)\r\n    case GameActionTypes.ADD_AI:\r\n      return withAddAiPlayer(action.payload, peerId)(prevState)\r\n    case GameActionTypes.ADD_LOCAL:\r\n      return withAddLocalPlayer(action.payload, peerId)(prevState)\r\n    case GameActionTypes.REMOVE_LOCAL_AI:\r\n      return withRemovePlayer(action.payload)(prevState)\r\n    default:\r\n      return prevState\r\n  }\r\n}\r\n\r\nexport const withGenericGameReducer = <State extends GenericGameState, Action extends GenericGameAction> (reducer: NetworkReducer<State, Action>): NetworkReducer<GenericGameState, GenericGameAction> => {\r\n  return (prevState, action) => {\r\n    return reducer(generalGameReducer(prevState, action) as State, action as Action)\r\n  }\r\n}\r\n","import { GameActionTypes, GenericGameAction } from 'gamenet'\r\nimport { Card } from './types'\r\nimport { NetworkAction } from 'smnet'\r\n\r\nexport enum Poker99ActionType {\r\n  PLAY_CARD,\r\n  LOCAL_MOVE,\r\n  END,\r\n}\r\n\r\nexport interface PlayCardPayload {\r\n  card: Card\r\n  increase?: boolean\r\n  target?: number\r\n}\r\n\r\nexport type Poker99Action = ({\r\n  type: Poker99ActionType.PLAY_CARD\r\n  payload: PlayCardPayload\r\n} | {\r\n  type: Poker99ActionType.LOCAL_MOVE\r\n  payload: Poker99Action\r\n} | {\r\n  type: Poker99ActionType.END\r\n} | {\r\n  type: GameActionTypes\r\n  payload: never\r\n} | GenericGameAction) & NetworkAction\r\n","import { Poker99State } from './Poker99State'\r\n\r\nexport enum Suit {\r\n  SPADE,\r\n  HEART,\r\n  CLUB,\r\n  DIAMOND\r\n}\r\n\r\nexport interface Card {\r\n  suit: Suit\r\n  number: number\r\n}\r\n\r\nexport type Deck = Card[]\r\n\r\nexport type StateMapper = (prevState: Poker99State) => Poker99State\r\n","import { useEffect, useMemo, useState } from 'react'\r\nimport { NetworkAction, NetworkReducer, NetworkState } from './types'\r\nimport { Network } from './Network'\r\nimport { StateManager } from './StateManager'\r\nimport { PeerFactory } from './PeerFactory'\r\nimport { logger } from './Logger'\r\n\r\nexport interface UseNetworkReturn<State extends NetworkState, Action extends NetworkAction> {\r\n  state: State\r\n  connected: boolean\r\n  networkName: string | undefined\r\n  join: (networkName: string, peerFactory?: PeerFactory) => Promise<void>\r\n  leave: () => Promise<void>\r\n  dispatch: (action: Action) => Promise<void>\r\n  isAdmin: boolean\r\n  myId?: string\r\n  kick: (id: string) => Promise<void>\r\n}\r\n\r\nexport function useNetwork<State extends NetworkState = NetworkState, Action extends NetworkAction = NetworkAction> (reducer: NetworkReducer<State, Action>, initialState: State): UseNetworkReturn<State, Action> {\r\n  const [state, setState] = useState(initialState)\r\n  const network = useMemo(() => new Network(reducer, StateManager.make(initialState, setState, 10)), [])\r\n  useEffect(() => {\r\n    if (process.env.REACT_APP_DISABLE_SMNET_WINDOW_VAR === undefined) {\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/ban-ts-comment\r\n      // @ts-expect-error\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n      window.stateHistory = network.getHistory; window.smnetLog = logger; window.network = network\r\n    }\r\n    return () => {\r\n      network.leave()\r\n        .catch(logger.error)\r\n    }\r\n  }, [network])\r\n  return Object.freeze({\r\n    join: network.join.bind(network),\r\n    leave: network.leave.bind(network),\r\n    dispatch: network.dispatch.bind(network),\r\n    state,\r\n    connected: network.connected,\r\n    networkName: network.getNetworkName(),\r\n    isAdmin: network.isAdmin,\r\n    myId: network.myId,\r\n    kick: network.kick\r\n  })\r\n}\r\n","import { GenericGameState } from 'gamenet'\r\nimport { Deck } from './types'\r\n\r\nexport class Poker99State extends GenericGameState {\r\n  maxPlayer = 4\r\n  minPlayer = 4\r\n  turn = 0\r\n  direction = 1\r\n  points = 0\r\n  dead: Record<number, true> = {}\r\n  drawDeck: Deck = []\r\n  trashDeck: Deck = []\r\n  playerDeck: Deck[] = []\r\n  winner?: number\r\n  logs: string[] = []\r\n}\r\n","export const cardAmount: Record<number, number> = {\r\n  1: 1, // spade set 1\r\n  2: 2,\r\n  3: 3,\r\n  4: 0, // reverse\r\n  5: 0, // target\r\n  6: 6,\r\n  7: 7,\r\n  8: 8,\r\n  9: 9,\r\n  10: 10, // +- 10\r\n  11: 0, //  skip\r\n  12: 20, // +=20\r\n  13: 99 //   set to 99\r\n}\r\n\r\nexport const maxCard = 5\r\n","import { NetworkReducer } from 'smnet'\r\nimport { Poker99State } from './Poker99State'\r\nimport { PlayCardPayload, Poker99Action, Poker99ActionType } from './Poker99Action'\r\nimport { Deck, StateMapper, Suit } from './types'\r\nimport { GameActionTypes, shuffle } from 'gamenet'\r\nimport { cardAmount, maxCard } from './constants'\r\nimport { minPossible } from './utils'\r\nimport cloneDeep from 'clone-deep'\r\n\r\nconst getFullDeck = (): Deck => {\r\n  const deck: Deck = []\r\n  for (let suit = 0; suit < 4; suit++) {\r\n    for (let number = 1; number <= 13; number++) {\r\n      deck.push({ suit, number })\r\n    }\r\n  }\r\n  return deck\r\n}\r\n\r\nconst withDrawCard: (playerId: number) => StateMapper = playerId => prevState => {\r\n  if (prevState.playerDeck[playerId].length >= maxCard) {\r\n    throw new Error(`cannot draw, ${prevState.players[playerId]} already has ${maxCard} cards`)\r\n  }\r\n  const card = prevState.drawDeck.shift()\r\n  if (card === undefined) {\r\n    return withDrawCard(playerId)({ ...prevState, drawDeck: shuffle(prevState.trashDeck), trashDeck: [] })\r\n  } else {\r\n    prevState.playerDeck[playerId].push(card)\r\n    return { ...prevState }\r\n  }\r\n}\r\n\r\nconst withInitGame: StateMapper = (prevState: Poker99State) => {\r\n  prevState = {\r\n    ...prevState,\r\n    drawDeck: [],\r\n    trashDeck: [],\r\n    playerDeck: [],\r\n    points: 0,\r\n    direction: 1,\r\n    turn: 0,\r\n    dead: {},\r\n    logs: ['game started'],\r\n    winner: undefined\r\n  }\r\n  prevState.drawDeck = shuffle(getFullDeck())\r\n  for (let id = 0; id < prevState.players.length; id++) {\r\n    prevState.playerDeck[id] = []\r\n    for (let k = 0; k < maxCard; k++) {\r\n      prevState = withDrawCard(id)(prevState)\r\n    }\r\n  }\r\n  return { ...prevState }\r\n}\r\n\r\nconst withPlayCard: (playerId: number, payload: PlayCardPayload) => StateMapper = (playerId, payload) => prevState => {\r\n  const { card } = payload\r\n  const cardStr = `${Suit[card.suit]}${card.number}`\r\n  if (prevState.playerDeck[playerId].find(({ suit, number }) => suit === card.suit && number === card.number) === undefined) {\r\n    throw new Error(`${prevState.players[playerId]} doesnt own card ${cardStr}`)\r\n  }\r\n  if (prevState.turn !== playerId) {\r\n    throw new Error('not your turn')\r\n  }\r\n  let sign = 1\r\n  let amount = cardAmount[card.number]\r\n  if (card.number === 10 || card.number === 12) {\r\n    if (payload.increase === undefined) {\r\n      throw new Error('card with number 10 or 12 require increase in payload')\r\n    }\r\n    sign = payload.increase ? 1 : -1\r\n  } else if (card.number === 13) {\r\n    amount = 99 - prevState.points\r\n  } else if (card.number === 1 && card.suit === Suit.SPADE) {\r\n    sign = -1\r\n    amount = prevState.points - 1\r\n  }\r\n  prevState.points += sign * amount\r\n  if (prevState.points > 99) {\r\n    throw new Error('playing this card will exceed 99')\r\n  }\r\n  prevState.playerDeck[playerId] = prevState.playerDeck[playerId].filter(({ suit, number }) => !(suit === card.suit && number === card.number))\r\n  prevState.trashDeck.push(card)\r\n  prevState = withDrawCard(playerId)(prevState)\r\n  if (card.number === 5) {\r\n    if (payload.target === undefined) {\r\n      throw new Error('Card with number 5 require target in payload')\r\n    }\r\n    if (payload.target === playerId) {\r\n      throw new Error('Target cannot be myself')\r\n    }\r\n    if (prevState.dead[payload.target]) {\r\n      throw new Error('cannot target on dead body')\r\n    }\r\n    prevState.logs.push(`${prevState.players[prevState.turn]} played ${cardStr}, targeted ${prevState.players[payload.target]}`)\r\n    prevState.turn = payload.target\r\n    return withBeforeNextTurn(prevState)\r\n  } else if (card.number === 4) {\r\n    prevState.direction *= -1\r\n    prevState.logs.push(`${prevState.players[prevState.turn]} played ${cardStr}, direction reversed`)\r\n  } else {\r\n    prevState.logs.push(`${prevState.players[prevState.turn]} played ${cardStr}, add ${sign * amount}, now ${prevState.points} points`)\r\n  }\r\n  return withBeforeNextTurn(withIncrementTurn(prevState))\r\n}\r\n\r\nconst withIncrementTurn: StateMapper = prevState => {\r\n  const nextPlayerId = (prevState.turn + prevState.maxPlayer + prevState.direction) % prevState.maxPlayer\r\n  return { ...prevState, turn: nextPlayerId }\r\n}\r\n\r\nconst withBeforeNextTurn: StateMapper = prevState => {\r\n  if (!prevState.dead[prevState.turn] && minPossible(prevState.points, prevState.playerDeck[prevState.turn])[0] > 99) {\r\n    prevState.logs.push(`${prevState.players[prevState.turn]} die, his card: ${prevState.playerDeck[prevState.turn].map(card => (\r\n      `${Suit[card.suit]}${card.number}`)\r\n    ).join(',')}`)\r\n    prevState.dead[prevState.turn] = true\r\n  }\r\n  if (Object.keys(prevState.dead).length === prevState.players.length - 1 && prevState.started) {\r\n    prevState.winner = [0, 1, 2, 3].filter(k => !prevState.dead[k])[0]\r\n  }\r\n  if (prevState.dead[prevState.turn]) {\r\n    return withBeforeNextTurn(withIncrementTurn({ ...prevState, turn: prevState.turn }))\r\n  } else {\r\n    return { ...prevState, turn: prevState.turn }\r\n  }\r\n}\r\n\r\nexport const Poker99Reducer: NetworkReducer<Poker99State, Poker99Action> = (prevState, action) => {\r\n  console.log('poker99 reducer')\r\n  const peerId = action.peerId\r\n  if (peerId === undefined) {\r\n    throw new Error('Expect peerId in action')\r\n  }\r\n  const playerId = (): number => {\r\n    const id = prevState.nameDict[prevState.members[peerId]]\r\n    if (id === undefined) {\r\n      throw new Error('game not started')\r\n    }\r\n    return id\r\n  }\r\n  switch (action.type) {\r\n    case GameActionTypes.START:\r\n      return withInitGame(prevState)\r\n    case Poker99ActionType.PLAY_CARD:\r\n      return withPlayCard(playerId(), action.payload)(cloneDeep(prevState))\r\n    case Poker99ActionType.LOCAL_MOVE:\r\n      return Poker99Reducer(prevState, action.payload)\r\n    case Poker99ActionType.END:\r\n      return { ...prevState, started: false }\r\n  }\r\n  return prevState\r\n}\r\n","import { Card, Suit } from './types'\r\nimport { cardAmount } from './constants'\r\n\r\nexport const minPossible = (current: number, cards: Card[]): number[] => {\r\n  let min = Infinity\r\n  let index = 0\r\n  cards.forEach(({ suit, number }, k) => {\r\n    let next = 0\r\n    if (suit === Suit.SPADE && number === 1) {\r\n      return [0, k]\r\n    } else if (number === 10) {\r\n      next = current - 10\r\n    } else if (number === 12) {\r\n      next = current - 20\r\n    } else if (number === 13) {\r\n      next = 99\r\n    } else {\r\n      next = current + cardAmount[number]\r\n    }\r\n    if (next < min) {\r\n      min = next\r\n      index = k\r\n    }\r\n  })\r\n  return [min, index]\r\n}\r\n","import React, { createContext, FunctionComponent, useContext } from 'react'\r\nimport { GameContextInterface, useGameNetwork } from 'gamenet'\r\nimport { Poker99State } from './poker99/Poker99State'\r\nimport { Poker99Reducer } from './poker99/Poker99Reducer'\r\nimport { Poker99Action } from './poker99/Poker99Action'\r\n\r\nconst Poker99Context = createContext<GameContextInterface<Poker99State, Poker99Action> | null>(null)\r\n\r\nexport const withPoker99Network = (Component: FunctionComponent): FunctionComponent => {\r\n  const WithGameNetwork: FunctionComponent = props => {\r\n    const network = useGameNetwork(Poker99Reducer, new Poker99State()) as GameContextInterface<Poker99State, Poker99Action>\r\n    return (\r\n      <Poker99Context.Provider value={network}>\r\n        <Component {...props} />\r\n      </Poker99Context.Provider>\r\n    )\r\n  }\r\n  WithGameNetwork.displayName = 'WithGameNetwork'\r\n  return WithGameNetwork\r\n}\r\n\r\nexport const usePoker99 = (): GameContextInterface<Poker99State, Poker99Action> => {\r\n  const network: GameContextInterface<Poker99State, Poker99Action> | null = useContext(Poker99Context)\r\n  if (network === null) {\r\n    throw new Error('please wrap it using withPoker99Network before calling this hook')\r\n  }\r\n  return network\r\n}\r\n","import React, { FunctionComponent, useState } from 'react'\r\nimport { v4 } from 'uuid'\r\nimport { usePoker99 } from './withPoker99Network'\r\n\r\nexport const Home: FunctionComponent = () => {\r\n  const { connect } = usePoker99()\r\n  const [name, setName] = useState(v4().substring(0, 4))\r\n  const [room, setRoom] = useState('my-room')\r\n  const [error, setError] = useState('')\r\n  return (\r\n    <div>\r\n      <h1>Demo Game - Poker 99</h1>\r\n      {error !== '' && <div>{error}</div>}\r\n      <div>\r\n        <label>your name: <input value={name} onChange={({ target: { value } }) => setName(value)}/></label>\r\n      </div>\r\n      <div>\r\n        <label>room code: <input value={room} onChange={({ target: { value } }) => setRoom(value)}/></label>\r\n      </div>\r\n      <button\r\n        disabled={name === '' || room === ''}\r\n        onClick={async () => await connect(name, room).catch((error: Error) => setError(error.message))}>\r\n        join\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\n","import React, { FunctionComponent, useState } from 'react'\r\nimport { PlayerType } from 'gamenet'\r\nimport { usePoker99 } from './withPoker99Network'\r\n\r\nexport const Room: FunctionComponent = () => {\r\n  const { room, state, leave, isAdmin, myId, kick, ready, start, addAi, addLocal, playerType } = usePoker99()\r\n  const [error, setError] = useState('')\r\n  const [name, setName] = useState('')\r\n  const handleStartClick = async (): Promise<void> => {\r\n    await start().catch((e: Error) => setError(e.message))\r\n  }\r\n  const handleReadyClick = async (): Promise<void> => {\r\n    await ready().catch((e: Error) => setError(e.message))\r\n  }\r\n  const handleAddLocalClick = async (): Promise<void> => {\r\n    setName('')\r\n    await addLocal(name).catch((e: Error) => setError(e.message))\r\n  }\r\n  const handleAddAiClick = async (): Promise<void> => {\r\n    setName('')\r\n    await addAi(name).catch((e: Error) => setError(e.message))\r\n  }\r\n  const displayPlayerType = {\r\n    [PlayerType.NORMAL]: '',\r\n    [PlayerType.LOCAL]: '(local)',\r\n    [PlayerType.AI]: '(ai)'\r\n  }\r\n  return (\r\n    <div>\r\n      <div>Room: {room}</div>\r\n      <div>\r\n        {Object.entries(state.members).map(([id, name]) => (\r\n          <div key={name}>\r\n            {name} {displayPlayerType[playerType(name)]}\r\n            {(id !== myId && isAdmin) &&\r\n            <button onClick={async () => await kick(id)}>kick</button>\r\n            }\r\n            {(state.ready[id] ?? false) && '(ready)'}\r\n          </div>)\r\n        )}\r\n      </div>\r\n      <div>\r\n        <button onClick={leave}>leave</button>\r\n        {isAdmin\r\n          ? <button onClick={handleStartClick}>start</button>\r\n          : <button onClick={handleReadyClick}>ready</button>}\r\n      </div>\r\n      <div>\r\n        <input\r\n          placeholder='new local/ai player name'\r\n          value={name}\r\n          onChange={({ target: { value } }) => setName(value)}\r\n        />\r\n        <button onClick={handleAddLocalClick}>Add local</button>\r\n        <button onClick={handleAddAiClick}>Add AI</button>\r\n      </div>\r\n      {error !== '' && <div>{error}</div>}\r\n    </div>\r\n  )\r\n}\r\n","import { Poker99State } from './Poker99State'\r\nimport { Poker99Action, Poker99ActionType } from './Poker99Action'\r\nimport { Card, Suit } from './types'\r\nimport { cardAmount } from './constants'\r\nimport { shuffle } from 'gamenet'\r\n\r\nconst isNormalCard = (card: Card): boolean => {\r\n  if (card.suit === Suit.SPADE && card.number === 1) {\r\n    return false\r\n  } else {\r\n    return [1, 2, 3, 6, 7, 8, 9].includes(card.number)\r\n  }\r\n}\r\n\r\nconst isSubtractable = (card: Card): boolean => {\r\n  return [10, 12].includes(card.number)\r\n}\r\n\r\nconst isSkippingCard = (card: Card): boolean => {\r\n  return [4, 5, 11, 13].includes(card.number)\r\n}\r\n\r\nexport const aiAction = (state: Poker99State, turn: number): Poker99Action => {\r\n  const cards = state.playerDeck[turn]\r\n  const points = state.points\r\n  const normalCards = cards.filter(isNormalCard).sort((a, b) => cardAmount[b.number] - cardAmount[a.number])\r\n  console.log('normal cards', normalCards, 'points', points)\r\n  const card13 = cards.find(c => c.number === 13)\r\n  if (card13 !== undefined) {\r\n    if (points !== 99 && normalCards.length < 3) {\r\n      return {\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card: card13\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const card of normalCards) {\r\n    console.log('should play normal?', card, points + cardAmount[card.number] <= 99)\r\n    if (points + cardAmount[card.number] <= 99) {\r\n      return ({\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card\r\n        }\r\n      })\r\n    }\r\n  }\r\n  const pmCards = cards.filter(isSubtractable)\r\n  for (const card of pmCards.sort((a, b) => b.number - a.number)) {\r\n    if (points + cardAmount[card.number] <= 99) {\r\n      return ({\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card,\r\n          increase: true\r\n        }\r\n      })\r\n    }\r\n  }\r\n  {\r\n    const card = cards.find(isSkippingCard)\r\n    if (card !== undefined) {\r\n      return {\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card,\r\n          target: state.nameDict[shuffle(state.players.filter((name, id) => !state.dead[id] && id !== turn))[0]]\r\n        }\r\n      }\r\n    }\r\n  }\r\n  for (const card of pmCards.sort((a, b) => a.number - b.number)) {\r\n    if (points - cardAmount[card.number] <= 99) {\r\n      return ({\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card,\r\n          increase: false\r\n        }\r\n      })\r\n    }\r\n  }\r\n  for (const card of cards) {\r\n    if (points - cardAmount[card.number] <= 99) {\r\n      return ({\r\n        type: Poker99ActionType.PLAY_CARD,\r\n        payload: {\r\n          card,\r\n          increase: false\r\n        }\r\n      })\r\n    }\r\n  }\r\n  throw new Error('reached an edge case')\r\n}\r\n","import React, { FunctionComponent, ReactNode, useEffect, useMemo, useRef, useState } from 'react'\r\nimport { usePoker99 } from './withPoker99Network'\r\nimport { Card, Suit } from './poker99/types'\r\nimport { Poker99Action, Poker99ActionType } from './poker99/Poker99Action'\r\nimport { aiAction } from './poker99/aiAction'\r\n\r\nexport const Game: FunctionComponent = () => {\r\n  const { state, myId, dispatch } = usePoker99()\r\n  const [target, setTarget] = useState(0)\r\n  const [increment, setIncrement] = useState(true)\r\n  const [error, setError] = useState('')\r\n  const myPlayerId = useMemo(() => {\r\n    try {\r\n      return state.nameDict[state.members[myId as string]]\r\n    } catch (e) {\r\n      return 0\r\n    }\r\n  }, [myId, state])\r\n  const myLocals = useMemo(() => {\r\n    try {\r\n      return Object.keys(state.localPlayers).filter(name => state.localPlayers[name] === myId).map(peerId => state.members[peerId])\r\n    } catch (e) {\r\n      return []\r\n    }\r\n  }, [myId, state])\r\n  const myAis = useMemo(() => {\r\n    try {\r\n      return Object.keys(state.aiPlayers).filter(name => state.aiPlayers[name] === myId).map(peerId => state.members[peerId])\r\n    } catch (e) {\r\n      return []\r\n    }\r\n  }, [myId, state])\r\n  let [hideDeck, setHideDeck] = useState(myLocals.length > 0)\r\n  const [renderedDeckId, setRenderedDeckId] = useState(myPlayerId)\r\n  const prevTurn = useRef(-1)\r\n  if (state.turn !== prevTurn.current) {\r\n    if (myLocals.length > 0) {\r\n      hideDeck = true\r\n      setHideDeck(true)\r\n      setRenderedDeckId(state.turn)\r\n    }\r\n    prevTurn.current = state.turn\r\n  }\r\n  const handleError = (e: Error): void => {\r\n    setError(e.message)\r\n  }\r\n  useEffect(() => {\r\n    if (myAis.includes(state.players[state.turn]) && state.started && state.winner === undefined) {\r\n      const cb = (): void => {\r\n        const action = aiAction(state, state.turn)\r\n        action.peerId = Object.keys(state.members).filter(peerId => state.members[peerId] === state.players[state.turn])[0]\r\n        dispatch({\r\n          type: Poker99ActionType.LOCAL_MOVE,\r\n          payload: action\r\n        }).catch(handleError)\r\n      }\r\n      const n = window.setTimeout(cb, 500)\r\n      return () => {\r\n        window.clearTimeout(n)\r\n      }\r\n    }\r\n  }, [state])\r\n  const d = state.direction === 1 ? '>' : '<'\r\n  const clickCard = (card: Card) => async () => {\r\n    const action: Poker99Action = {\r\n      type: Poker99ActionType.PLAY_CARD,\r\n      payload: {\r\n        card,\r\n        increase: increment,\r\n        target\r\n      }\r\n    }\r\n    if (state.turn === myPlayerId) {\r\n      await dispatch(action).then(() => setError('')).catch(handleError)\r\n    } else if (myLocals.includes(state.players[state.turn])) {\r\n      action.peerId = Object.keys(state.members).filter(peerId => state.members[peerId] === state.players[state.turn])[0]\r\n      await dispatch({\r\n        type: Poker99ActionType.LOCAL_MOVE,\r\n        payload: action\r\n      }).then(() => setError('')).catch(handleError)\r\n    }\r\n  }\r\n  const renderDeck = (playerId: number): ReactNode => state.playerDeck[playerId]?.map(card => (\r\n    <button key={card.number * 10 + card.suit} onClick={clickCard(card)}>\r\n      {Suit[card.suit]} {card.number}\r\n    </button>\r\n  ))\r\n  const renderLocalDeck = (): ReactNode => {\r\n    return hideDeck ? <button onClick={() => setHideDeck(false)}>show {state.players[renderedDeckId]}</button>\r\n      : renderDeck(renderedDeckId)\r\n  }\r\n  const again = async (): Promise<void> => {\r\n    await dispatch({\r\n      type: Poker99ActionType.END\r\n    }).catch(handleError)\r\n  }\r\n  return (<div>\r\n    <div>\r\n      <h3>{state.points}</h3>\r\n      <h6>{state.players[state.turn]}{'\\''}s turn</h6>\r\n      {error !== '' && <div style={{ color: 'red' }}>{error}</div>}\r\n      {state.winner !== undefined && <div>winner is {state.players[state.winner]}\r\n        <button onClick={again}>again</button>\r\n      </div>}\r\n      {state.players.map((name, id) => (\r\n        <span\r\n          key={name}\r\n          onClick={() => setTarget(id)}\r\n          style={{\r\n            fontWeight: state.turn === id ? 'bold' : 'normal',\r\n            textDecorationLine: state.dead[id] ? 'line-through' : 'none'\r\n          }}>\r\n          {name} {d}\r\n        </span>\r\n      ))}\r\n      <div>\r\n        {\r\n          myLocals.length === 0\r\n            ? renderDeck(myPlayerId)\r\n            : renderLocalDeck()\r\n        }\r\n      </div>\r\n      <div>\r\n        target: {target}\r\n      </div>\r\n      <button onClick={() => setIncrement(!increment)}>\r\n        {increment ? '+' : '-'}\r\n      </button>\r\n    </div>\r\n    <div>\r\n      {state.logs.slice().reverse().map((s, k) => <div key={k}>{s}</div>)}\r\n    </div>\r\n  </div>)\r\n}\r\n","import React, { FunctionComponent } from 'react'\r\nimport { Home } from './Home'\r\nimport { Room } from './Room'\r\nimport { Game } from './Game'\r\nimport { usePoker99, withPoker99Network } from './withPoker99Network'\r\nimport { GameAppState } from 'gamenet'\r\n\r\nexport const GameApp: FunctionComponent = withPoker99Network(() => {\r\n  const { gameAppState } = usePoker99()\r\n  switch (gameAppState) {\r\n    case GameAppState.HOME:\r\n      return <Home />\r\n    case GameAppState.ROOM:\r\n      return <Room />\r\n    case GameAppState.GAME:\r\n      return <Game />\r\n    default:\r\n      throw new Error('unknown state')\r\n  }\r\n})\r\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport reportWebVitals from './reportWebVitals'\nimport { GameApp } from './demo-gamenet/GameApp'\n\nReactDOM.render(\n  <GameApp/>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}